#include <vld.h>
#include <stdio.h>
#include <windows.h>
#include "PmxReader.h"
#include "FbxHelper.h"

static void SavePmxToFbx(PmxReader & pmx)
{
	FbxHelper fbx;

	FbxHelper::Shape * shp = fbx.BeginShape(pmx.ModelName.c_str());
	{
		// 写入顶点
		shp->InitPositionSize(pmx.VertexList.size());

		int count = 0;
		for (auto & item : pmx.VertexList)
		{
			shp->SetPositionAt(item.Position, count);
			shp->AddNormal(item.Normal);
			shp->AddUV(item.UV);
			++count;
		}

		// 遍历材质组
		int currFace = 0;
		for (size_t matID = 0, szMat = pmx.MaterialList.size(); matID < szMat; ++matID)
		{
			// 写入材质
			auto & currMat = pmx.MaterialList[matID];
			FbxSurfacePhong * pFbxMat = fbx.NewPhong(currMat.Name.c_str());
			pFbxMat->Diffuse.Set(FbxDouble3(currMat.Diffuse.X, currMat.Diffuse.Y, currMat.Diffuse.Z));
			pFbxMat->Ambient.Set(FbxDouble3(currMat.Ambient.X, currMat.Ambient.Y, currMat.Ambient.Z));
			pFbxMat->Specular.Set(FbxDouble3(currMat.Specular.X, currMat.Specular.Y, currMat.Specular.Z));
			pFbxMat->SpecularFactor = currMat.Power;
			// 设置纹理
			FbxFileTexture * pFbxTex = fbx.NewTexture("Diffuse", currMat.Tex.c_str());
			pFbxMat->Diffuse.ConnectSrcObject(pFbxTex);
			// 设置透明通道
			FbxFileTexture * pFbxOpacityTex = fbx.NewTexture("Opacity", currMat.Tex.c_str());
			pFbxOpacityTex->SetAlphaSource(FbxTexture::eBlack);
			pFbxMat->TransparentColor.ConnectSrcObject(pFbxOpacityTex);
			shp->AddMaterial(pFbxMat);

			// 写入当前材质对应的面
			count = 0;
			for (int endFace = currFace + currMat.FaceCount; currFace < endFace; ++currFace)
			{
				if (count == 0)
				{
					shp->BeginFace(matID);
				}

				shp->AddIndex(pmx.FaceList[currFace]);

				if (count == 2)
				{
					shp->EndFace();
					count = 0;
				}
				else
					++count;
			}
		}
	}
	fbx.EndShape(shp);

	fbx.SaveScene("out");
}

//////////////////////////////////////////////////////////////////////////
static void * ReadFile(const wchar_t * strFileName, size_t & szFileLen)
{
	void * pResult = 0;
	FILE * fp = 0;
	_wfopen_s(&fp, strFileName, L"rb");
	if (fp)
	{
		fseek(fp, 0, SEEK_END);
		szFileLen = ftell(fp);
		fseek(fp, 0, SEEK_SET);

		pResult = malloc(szFileLen);
		fread(pResult, szFileLen, 1, fp);

		fclose(fp);
	}
	return pResult;
}

int wmain(int argc, const wchar_t ** argv)
{
	if (argc == 2)
	{
		size_t flen = 0;
		void * pBuf = ReadFile(argv[1], flen);
		if (pBuf)
		{
			PmxReader reader(pBuf, flen);
			free(pBuf);

			SavePmxToFbx(reader);
		}
	}
	return 0;
}