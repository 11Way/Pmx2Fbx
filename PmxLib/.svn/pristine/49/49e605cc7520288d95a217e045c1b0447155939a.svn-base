
#include <string>
#include "FbxHelper.h"

#ifdef IOS_REF
#undef  IOS_REF
#define IOS_REF (*(m_pSdkMgr->GetIOSettings()))
#endif

#define	UVSet1	"UVSet1"

FbxHelper::FbxHelper()
{
	m_pSdkMgr = FbxManager::Create();
	if (!m_pSdkMgr)
	{
		throw std::wstring(L"Error: Unable to create FBX Manager!\n");
	}
	FbxIOSettings * ios = FbxIOSettings::Create(m_pSdkMgr, IOSROOT);
	m_pSdkMgr->SetIOSettings(ios);

	m_pScene = FbxScene::Create(m_pSdkMgr, "Scene");
}

FbxHelper::~FbxHelper()
{
	m_pSdkMgr->Destroy();
}

void FbxHelper::SetInfo()
{
	FbxDocumentInfo * pSceneInfo = FbxDocumentInfo::Create(m_pSdkMgr, "Info");
	m_pScene->SetSceneInfo(pSceneInfo);
}

bool FbxHelper::SaveScene(const char * pFileName, bool pEmbedMedia, int pFileFormat)
{
	int lMajor, lMinor, lRevision;
	bool lStatus = true;

	// Create an exporter.
	FbxExporter * lExporter = FbxExporter::Create(m_pSdkMgr, "");

	if (pFileFormat < 0 || pFileFormat >= m_pSdkMgr->GetIOPluginRegistry()->GetWriterFormatCount())
	{
		// Write in fall back format in less no ASCII format found
		pFileFormat = m_pSdkMgr->GetIOPluginRegistry()->GetNativeWriterFormat();

		// Try to export in ASCII if possible
		int lFormatIndex, lFormatCount = m_pSdkMgr->GetIOPluginRegistry()->GetWriterFormatCount();

		for (lFormatIndex = 0; lFormatIndex < lFormatCount; lFormatIndex++)
		{
			if (m_pSdkMgr->GetIOPluginRegistry()->WriterIsFBX(lFormatIndex))
			{
				FbxString lDesc = m_pSdkMgr->GetIOPluginRegistry()->GetWriterFormatDescription(lFormatIndex);
				const char * strBinary = "ascii";
				if (lDesc.Find(strBinary) >= 0)
				{
					pFileFormat = lFormatIndex;
					break;
				}
			}
		}
	}

	// Set the export states. By default, the export states are always set to 
	// true except for the option eEXPORT_TEXTURE_AS_EMBEDDED. The code below 
	// shows how to change these states.
	IOS_REF.SetBoolProp(EXP_FBX_MATERIAL, true);
	IOS_REF.SetBoolProp(EXP_FBX_TEXTURE, true);
	IOS_REF.SetBoolProp(EXP_FBX_EMBEDDED, pEmbedMedia);
	IOS_REF.SetBoolProp(EXP_FBX_SHAPE, true);
	IOS_REF.SetBoolProp(EXP_FBX_GOBO, true);
	IOS_REF.SetBoolProp(EXP_FBX_ANIMATION, true);
	IOS_REF.SetBoolProp(EXP_FBX_GLOBAL_SETTINGS, true);

	// Initialize the exporter by providing a filename.
	if (lExporter->Initialize(pFileName, pFileFormat, m_pSdkMgr->GetIOSettings()) == false)
	{
		FBXSDK_printf("Call to FbxExporter::Initialize() failed.\n");
		FBXSDK_printf("Error returned: %s\n\n", lExporter->GetStatus().GetErrorString());
		return false;
	}

	FbxManager::GetFileFormatVersion(lMajor, lMinor, lRevision);
	FBXSDK_printf("FBX file format version %d.%d.%d\n\n", lMajor, lMinor, lRevision);

	// Export the scene.
	lStatus = lExporter->Export(m_pScene);

	// Destroy the exporter.
	lExporter->Destroy();
	return lStatus;
}

FbxSurfacePhong * FbxHelper::NewPhong(const char * strName)
{
	FbxSurfacePhong * ptr = FbxSurfacePhong::Create(m_pScene, strName);
	return ptr;
}

FbxFileTexture * FbxHelper::NewTexture(const char * strName, const char * strFileName)
{
	FbxFileTexture * ptr = FbxFileTexture::Create(m_pScene, strName);
	ptr->SetFileName(strFileName);
	ptr->SetTextureUse(FbxTexture::eStandard);
	ptr->SetMappingType(FbxTexture::eUV);
	ptr->SetMaterialUse(FbxFileTexture::eModelMaterial);
	ptr->SetSwapUV(false);
	ptr->SetTranslation(0.0, 0.0);
	ptr->SetScale(1.0, 1.0);
	ptr->SetRotation(0.0, 0.0);
	ptr->UVSet.Set(UVSet1);
	return ptr;
}

//////////////////////////////////////////////////////////////////////////
FbxHelper::Shape * FbxHelper::BeginShape(const char * strName)
{
	return new Shape(this, strName);
}

void FbxHelper::EndShape(Shape * pShape)
{
	m_pScene->GetRootNode()->AddChild(pShape->m_pNode);
	delete pShape;
}

FbxHelper::Shape::Shape(FbxHelper * owner, const char * strName)
	: m_pOwner(owner)
{
	m_pNode = FbxNode::Create(m_pOwner->m_pScene, strName);
	m_pMesh = FbxMesh::Create(m_pOwner->m_pScene, strName);
	m_pNode->SetNodeAttribute(m_pMesh);

	m_pNormalElement = m_pMesh->CreateElementNormal();
	m_pNormalElement->SetMappingMode(FbxGeometryElement::eByControlPoint);
	m_pNormalElement->SetReferenceMode(FbxGeometryElement::eDirect);

	m_pUVElement = m_pMesh->CreateElementUV(UVSet1);
	m_pUVElement->SetMappingMode(FbxGeometryElement::eByControlPoint);
	m_pUVElement->SetReferenceMode(FbxGeometryElement::eDirect);

	m_pMaterialElement = m_pMesh->CreateElementMaterial();
	m_pMaterialElement->SetMappingMode(FbxGeometryElement::eByPolygon);
	m_pMaterialElement->SetReferenceMode(FbxGeometryElement::eIndexToDirect);
}

void FbxHelper::Shape::InitPositionSize(int count)
{
	m_pMesh->InitControlPoints(count);
}

void FbxHelper::Shape::SetPositionAt(const Vector3 & pos, int idx)
{
	m_pMesh->SetControlPointAt(FbxVector4(pos.X, pos.Y, pos.Z), idx);
}

void FbxHelper::Shape::AddNormal(const Vector3 & normal)
{
	m_pNormalElement->GetDirectArray().Add(FbxVector4(normal.X, normal.Y, normal.Z));
}

void FbxHelper::Shape::AddUV(const Vector2 & uv)
{
	m_pUVElement->GetDirectArray().Add(FbxVector2(uv.X, -uv.Y));
}

void FbxHelper::Shape::BeginFace(int matID)
{
	m_pMesh->BeginPolygon(matID);
}

void FbxHelper::Shape::AddIndex(int vertID)
{
	m_pMesh->AddPolygon(vertID);
}

void FbxHelper::Shape::EndFace()
{
	m_pMesh->EndPolygon();
}

void FbxHelper::Shape::AddMaterial(FbxSurfaceMaterial * pMaterial)
{
	m_pNode->AddMaterial(pMaterial);
}